/*
 * Copyright (c) 1992 The Regents of the University of California.
 * All rights reserved.
 *
 * Permission to use, copy, modify, and distribute this software and its
 * documentation for any purpose, without fee, and without written agreement is
 * hereby granted, provided that the above copyright notice and the following
 * two paragraphs appear in all copies of this software.
 *
 * IN NO EVENT SHALL THE UNIVERSITY OF CALIFORNIA BE LIABLE TO ANY PARTY FOR
 * DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES ARISING OUT
 * OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF THE UNIVERSITY OF
 * CALIFORNIA HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 * THE UNIVERSITY OF CALIFORNIA SPECIFICALLY DISCLAIMS ANY WARRANTIES,
 * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY
 * AND FITNESS FOR A PARTICULAR PURPOSE.  THE SOFTWARE PROVIDED HEREUNDER IS
 * ON AN "AS IS" BASIS, AND THE UNIVERSITY OF CALIFORNIA HAS NO OBLIGATION TO
 * PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
 */
#include "video.h"
#include "decoders.h"

/* Array mapping zigzag to array pointer offset. */

static const unsigned char zigzag_direct[64] =
{    0,  1,  8, 16,  9,  2,  3, 10,
    17, 24, 32, 25, 18, 11,  4,  5,
    12, 19, 26, 33, 40, 48, 41, 34,
    27, 20, 13,  6,  7, 14, 21, 28,
    35, 42, 49, 56, 57, 50, 43, 36,
    29, 22, 15, 23, 30, 37, 44, 51,
    58, 59, 52, 45, 38, 31, 39, 46,
    53, 60, 61, 54, 47, 55, 62, 63
};

/* Bit masks used by bit i/o operations. */

const unsigned long BitMask[33] =
{   0x00000000L, 0x00000001L, 0x00000003L, 0x00000007L,
    0x0000000fL, 0x0000001fL, 0x0000003fL, 0x0000007fL,
    0x000000ffL, 0x000001ffL, 0x000003ffL, 0x000007ffL,
    0x00000fffL, 0x00001fffL, 0x00003fffL, 0x00007fffL,
    0x0000ffffL, 0x0001ffffL, 0x0003ffffL, 0x0007ffffL,
    0x000fffffL, 0x001fffffL, 0x003fffffL, 0x007fffffL,
    0x00ffffffL, 0x01ffffffL, 0x03ffffffL, 0x07ffffffL,
    0x0fffffffL, 0x1fffffffL, 0x3fffffffL, 0x7fffffffL,
    0xffffffffL
};

/* Decoding tables for dct_dc_size_luminance */

static const unsigned char dct_dc_size_luminance[32] =
{   0x12, 0x12, 0x12, 0x12, 0x12, 0x12, 0x12, 0x12,
    0x22, 0x22, 0x22, 0x22, 0x22, 0x22, 0x22, 0x22,
    0x03, 0x03, 0x03, 0x03, 0x33, 0x33, 0x33, 0x33,
    0x43, 0x43, 0x43, 0x43, 0x54, 0x54, 0x65, 0x00
};

static const unsigned char dct_dc_size_luminance1[16] =
{   0x76, 0x76, 0x76, 0x76, 0x76, 0x76, 0x76, 0x76,
    0x87, 0x87, 0x87, 0x87, 0x98, 0x98, 0xA9, 0xB9
};

/* Decoding tables for dct_dc_size_chrominance */

static const unsigned char dct_dc_size_chrominance[32] =
{   0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02,
    0x12, 0x12, 0x12, 0x12, 0x12, 0x12, 0x12, 0x12,
    0x22, 0x22, 0x22, 0x22, 0x22, 0x22, 0x22, 0x22,
    0x33, 0x33, 0x33, 0x33, 0x44, 0x44, 0x55, 0x00
};

static const unsigned char dct_dc_size_chrominance1[32] =
{   0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66,
    0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66,
    0x77, 0x77, 0x77, 0x77, 0x77, 0x77, 0x77, 0x77,
    0x88, 0x88, 0x88, 0x88, 0x99, 0x99, 0xAA, 0xBA
};

/* DCT coeff tables. */

static const unsigned short dct_coeff_tbl_0[256] =
{
0xffff, 0xffff, 0xffff, 0xffff,
0xffff, 0xffff, 0xffff, 0xffff,
0xffff, 0xffff, 0xffff, 0xffff,
0xffff, 0xffff, 0xffff, 0xffff,
0x052f, 0x051f, 0x050f, 0x04ff,
0x183f, 0x402f, 0x3c2f, 0x382f,
0x342f, 0x302f, 0x2c2f, 0x7c1f,
0x781f, 0x741f, 0x701f, 0x6c1f,
0x028e, 0x028e, 0x027e, 0x027e,
0x026e, 0x026e, 0x025e, 0x025e,
0x024e, 0x024e, 0x023e, 0x023e,
0x022e, 0x022e, 0x021e, 0x021e,
0x020e, 0x020e, 0x04ee, 0x04ee,
0x04de, 0x04de, 0x04ce, 0x04ce,
0x04be, 0x04be, 0x04ae, 0x04ae,
0x049e, 0x049e, 0x048e, 0x048e,
0x01fd, 0x01fd, 0x01fd, 0x01fd,
0x01ed, 0x01ed, 0x01ed, 0x01ed,
0x01dd, 0x01dd, 0x01dd, 0x01dd,
0x01cd, 0x01cd, 0x01cd, 0x01cd,
0x01bd, 0x01bd, 0x01bd, 0x01bd,
0x01ad, 0x01ad, 0x01ad, 0x01ad,
0x019d, 0x019d, 0x019d, 0x019d,
0x018d, 0x018d, 0x018d, 0x018d,
0x017d, 0x017d, 0x017d, 0x017d,
0x016d, 0x016d, 0x016d, 0x016d,
0x015d, 0x015d, 0x015d, 0x015d,
0x014d, 0x014d, 0x014d, 0x014d,
0x013d, 0x013d, 0x013d, 0x013d,
0x012d, 0x012d, 0x012d, 0x012d,
0x011d, 0x011d, 0x011d, 0x011d,
0x010d, 0x010d, 0x010d, 0x010d,
0x282c, 0x282c, 0x282c, 0x282c,
0x282c, 0x282c, 0x282c, 0x282c,
0x242c, 0x242c, 0x242c, 0x242c,
0x242c, 0x242c, 0x242c, 0x242c,
0x143c, 0x143c, 0x143c, 0x143c,
0x143c, 0x143c, 0x143c, 0x143c,
0x0c4c, 0x0c4c, 0x0c4c, 0x0c4c,
0x0c4c, 0x0c4c, 0x0c4c, 0x0c4c,
0x085c, 0x085c, 0x085c, 0x085c,
0x085c, 0x085c, 0x085c, 0x085c,
0x047c, 0x047c, 0x047c, 0x047c,
0x047c, 0x047c, 0x047c, 0x047c,
0x046c, 0x046c, 0x046c, 0x046c,
0x046c, 0x046c, 0x046c, 0x046c,
0x00fc, 0x00fc, 0x00fc, 0x00fc,
0x00fc, 0x00fc, 0x00fc, 0x00fc,
0x00ec, 0x00ec, 0x00ec, 0x00ec,
0x00ec, 0x00ec, 0x00ec, 0x00ec,
0x00dc, 0x00dc, 0x00dc, 0x00dc,
0x00dc, 0x00dc, 0x00dc, 0x00dc,
0x00cc, 0x00cc, 0x00cc, 0x00cc,
0x00cc, 0x00cc, 0x00cc, 0x00cc,
0x681c, 0x681c, 0x681c, 0x681c,
0x681c, 0x681c, 0x681c, 0x681c,
0x641c, 0x641c, 0x641c, 0x641c,
0x641c, 0x641c, 0x641c, 0x641c,
0x601c, 0x601c, 0x601c, 0x601c,
0x601c, 0x601c, 0x601c, 0x601c,
0x5c1c, 0x5c1c, 0x5c1c, 0x5c1c,
0x5c1c, 0x5c1c, 0x5c1c, 0x5c1c,
0x581c, 0x581c, 0x581c, 0x581c,
0x581c, 0x581c, 0x581c, 0x581c
};

static const unsigned short dct_coeff_tbl_1[16] =
{
0x00bb, 0x202b, 0x103b, 0x00ab,
0x084b, 0x1c2b, 0x541b, 0x501b,
0x009b, 0x4c1b, 0x481b, 0x045b,
0x0c3b, 0x008b, 0x182b, 0x441b
};

static const unsigned short dct_coeff_tbl_2[8] =
{
0x4019, 0x1429, 0x0079, 0x0839,
0x0449, 0x3c19, 0x3819, 0x1029
};

static const unsigned short dct_coeff_next[256] =
{
0x0000, 0x0000, 0x0000, 0x0000,
0x0005, 0x0005, 0x0005, 0x0005,
0x0826, 0x0826, 0x2416, 0x2416,
0x0046, 0x0046, 0x2016, 0x2016,
0x1c15, 0x1c15, 0x1c15, 0x1c15,
0x1815, 0x1815, 0x1815, 0x1815,
0x0425, 0x0425, 0x0425, 0x0425,
0x1415, 0x1415, 0x1415, 0x1415,
0x3417, 0x0067, 0x3017, 0x2c17,
0x0c27, 0x0437, 0x0057, 0x2817,
0x0034, 0x0034, 0x0034, 0x0034,
0x0034, 0x0034, 0x0034, 0x0034,
0x1014, 0x1014, 0x1014, 0x1014,
0x1014, 0x1014, 0x1014, 0x1014,
0x0c14, 0x0c14, 0x0c14, 0x0c14,
0x0c14, 0x0c14, 0x0c14, 0x0c14,
0x0023, 0x0023, 0x0023, 0x0023,
0x0023, 0x0023, 0x0023, 0x0023,
0x0023, 0x0023, 0x0023, 0x0023,
0x0023, 0x0023, 0x0023, 0x0023,
0x0813, 0x0813, 0x0813, 0x0813,
0x0813, 0x0813, 0x0813, 0x0813,
0x0813, 0x0813, 0x0813, 0x0813,
0x0813, 0x0813, 0x0813, 0x0813,
0x0412, 0x0412, 0x0412, 0x0412,
0x0412, 0x0412, 0x0412, 0x0412,
0x0412, 0x0412, 0x0412, 0x0412,
0x0412, 0x0412, 0x0412, 0x0412,
0x0412, 0x0412, 0x0412, 0x0412,
0x0412, 0x0412, 0x0412, 0x0412,
0x0412, 0x0412, 0x0412, 0x0412,
0x0412, 0x0412, 0x0412, 0x0412,
0xffe1, 0xffe1, 0xffe1, 0xffe1,
0xffe1, 0xffe1, 0xffe1, 0xffe1,
0xffe1, 0xffe1, 0xffe1, 0xffe1,
0xffe1, 0xffe1, 0xffe1, 0xffe1,
0xffe1, 0xffe1, 0xffe1, 0xffe1,
0xffe1, 0xffe1, 0xffe1, 0xffe1,
0xffe1, 0xffe1, 0xffe1, 0xffe1,
0xffe1, 0xffe1, 0xffe1, 0xffe1,
0xffe1, 0xffe1, 0xffe1, 0xffe1,
0xffe1, 0xffe1, 0xffe1, 0xffe1,
0xffe1, 0xffe1, 0xffe1, 0xffe1,
0xffe1, 0xffe1, 0xffe1, 0xffe1,
0xffe1, 0xffe1, 0xffe1, 0xffe1,
0xffe1, 0xffe1, 0xffe1, 0xffe1,
0xffe1, 0xffe1, 0xffe1, 0xffe1,
0xffe1, 0xffe1, 0xffe1, 0xffe1,
0x0011, 0x0011, 0x0011, 0x0011,
0x0011, 0x0011, 0x0011, 0x0011,
0x0011, 0x0011, 0x0011, 0x0011,
0x0011, 0x0011, 0x0011, 0x0011,
0x0011, 0x0011, 0x0011, 0x0011,
0x0011, 0x0011, 0x0011, 0x0011,
0x0011, 0x0011, 0x0011, 0x0011,
0x0011, 0x0011, 0x0011, 0x0011,
0x0011, 0x0011, 0x0011, 0x0011,
0x0011, 0x0011, 0x0011, 0x0011,
0x0011, 0x0011, 0x0011, 0x0011,
0x0011, 0x0011, 0x0011, 0x0011,
0x0011, 0x0011, 0x0011, 0x0011,
0x0011, 0x0011, 0x0011, 0x0011,
0x0011, 0x0011, 0x0011, 0x0011,
0x0011, 0x0011, 0x0011, 0x0011
};

static const unsigned short dct_coeff_first[256] =
{
0x0000, 0x0000, 0x0000, 0x0000,
0x0005, 0x0005, 0x0005, 0x0005,
0x0826, 0x0826, 0x2416, 0x2416,
0x0046, 0x0046, 0x2016, 0x2016,
0x1c15, 0x1c15, 0x1c15, 0x1c15,
0x1815, 0x1815, 0x1815, 0x1815,
0x0425, 0x0425, 0x0425, 0x0425,
0x1415, 0x1415, 0x1415, 0x1415,
0x3417, 0x0067, 0x3017, 0x2c17,
0x0c27, 0x0437, 0x0057, 0x2817,
0x0034, 0x0034, 0x0034, 0x0034,
0x0034, 0x0034, 0x0034, 0x0034,
0x1014, 0x1014, 0x1014, 0x1014,
0x1014, 0x1014, 0x1014, 0x1014,
0x0c14, 0x0c14, 0x0c14, 0x0c14,
0x0c14, 0x0c14, 0x0c14, 0x0c14,
0x0023, 0x0023, 0x0023, 0x0023,
0x0023, 0x0023, 0x0023, 0x0023,
0x0023, 0x0023, 0x0023, 0x0023,
0x0023, 0x0023, 0x0023, 0x0023,
0x0813, 0x0813, 0x0813, 0x0813,
0x0813, 0x0813, 0x0813, 0x0813,
0x0813, 0x0813, 0x0813, 0x0813,
0x0813, 0x0813, 0x0813, 0x0813,
0x0412, 0x0412, 0x0412, 0x0412,
0x0412, 0x0412, 0x0412, 0x0412,
0x0412, 0x0412, 0x0412, 0x0412,
0x0412, 0x0412, 0x0412, 0x0412,
0x0412, 0x0412, 0x0412, 0x0412,
0x0412, 0x0412, 0x0412, 0x0412,
0x0412, 0x0412, 0x0412, 0x0412,
0x0412, 0x0412, 0x0412, 0x0412,
0x0010, 0x0010, 0x0010, 0x0010,
0x0010, 0x0010, 0x0010, 0x0010,
0x0010, 0x0010, 0x0010, 0x0010,
0x0010, 0x0010, 0x0010, 0x0010,
0x0010, 0x0010, 0x0010, 0x0010,
0x0010, 0x0010, 0x0010, 0x0010,
0x0010, 0x0010, 0x0010, 0x0010,
0x0010, 0x0010, 0x0010, 0x0010,
0x0010, 0x0010, 0x0010, 0x0010,
0x0010, 0x0010, 0x0010, 0x0010,
0x0010, 0x0010, 0x0010, 0x0010,
0x0010, 0x0010, 0x0010, 0x0010,
0x0010, 0x0010, 0x0010, 0x0010,
0x0010, 0x0010, 0x0010, 0x0010,
0x0010, 0x0010, 0x0010, 0x0010,
0x0010, 0x0010, 0x0010, 0x0010,
0x0010, 0x0010, 0x0010, 0x0010,
0x0010, 0x0010, 0x0010, 0x0010,
0x0010, 0x0010, 0x0010, 0x0010,
0x0010, 0x0010, 0x0010, 0x0010,
0x0010, 0x0010, 0x0010, 0x0010,
0x0010, 0x0010, 0x0010, 0x0010,
0x0010, 0x0010, 0x0010, 0x0010,
0x0010, 0x0010, 0x0010, 0x0010,
0x0010, 0x0010, 0x0010, 0x0010,
0x0010, 0x0010, 0x0010, 0x0010,
0x0010, 0x0010, 0x0010, 0x0010,
0x0010, 0x0010, 0x0010, 0x0010,
0x0010, 0x0010, 0x0010, 0x0010,
0x0010, 0x0010, 0x0010, 0x0010,
0x0010, 0x0010, 0x0010, 0x0010,
0x0010, 0x0010, 0x0010, 0x0010
};


/*
 *--------------------------------------------------------------
 *
 * ParseReconBlock --
 *
 *	Parse values for block structure from bitstream.
 *      n is an indication of the position of the block within
 *      the macroblock (i.e. 0-5) and indicates the type of
 *      block (i.e. luminance or chrominance). Reconstructs
 *      coefficients from values parsed and puts in
 *      block.dct_recon array in vid stream structure.
 *
 * Results:
 *	
 *
 * Side effects:
 *      Bit stream irreversibly parsed.
 *
 *--------------------------------------------------------------
 */

#define DCT_recon vid_stream->block.dct_recon
#define DCT_dc_y_past vid_stream->block.dct_dc_y_past
#define DCT_dc_cr_past vid_stream->block.dct_dc_cr_past
#define DCT_dc_cb_past vid_stream->block.dct_dc_cb_past

void ParseReconBlock( VidStream *vid_stream, int n )
{
  unsigned long diff;
  short coeff, i, run, qscale, *reconptr;

  reconptr = DCT_recon[0];

  /*
   * Hand coded version of memset that's a little faster...
   * Old call: memset(DCT_recon, 0, 64*sizeof(short));
   */
  {
    long *p = (long *) reconptr;
    *p++ = 0; *p++ = 0; *p++ = 0; *p++ = 0;
    *p++ = 0; *p++ = 0; *p++ = 0; *p++ = 0;
    *p++ = 0; *p++ = 0; *p++ = 0; *p++ = 0;
    *p++ = 0; *p++ = 0; *p++ = 0; *p++ = 0;
    *p++ = 0; *p++ = 0; *p++ = 0; *p++ = 0;
    *p++ = 0; *p++ = 0; *p++ = 0; *p++ = 0;
    *p++ = 0; *p++ = 0; *p++ = 0; *p++ = 0;
    *p++ = 0; *p++ = 0; *p++ = 0; *p++ = 0;
  }

  if (vid_stream->mblock.mb_intra) {

    if (n < 4) {

      DecodeDCTDCSizeLum(coeff, diff)
      if (coeff >>= 4) {
	get_bits(coeff, diff)
	if (diff <= BitMask[coeff - 1]) diff -= BitMask[coeff];
	coeff = (short) diff;
      }
      coeff += DCT_dc_y_past;
      DCT_dc_y_past = coeff;
    }
    else {
	
      DecodeDCTDCSizeChrom(coeff, diff)
      if (coeff >>= 4) {
	get_bits(coeff, diff)
	if (diff <= BitMask[coeff - 1]) diff -= BitMask[coeff];
	coeff = (short) diff;
      }
      if (n == 4) {
	coeff += DCT_dc_cr_past;
	DCT_dc_cr_past = coeff;
      }
      else {
	coeff += DCT_dc_cb_past;
	DCT_dc_cb_past = coeff;
      }
    }

    reconptr[0] = coeff <<= 3; i = 0;

    if (vid_stream->picture.code_type != 4) {

      qscale = vid_stream->slice.quant_scale;

      for (;;) {

	i++;

	DecodeDCTCoeffNext(run, coeff, diff, i)

	reconptr[zigzag_direct[i]] = (coeff * qscale *
	  (int)vid_stream->intra_quant_matrix[i] + 4) >> 3;
      }

      i -= run; i--;
    }
  }
  else {

    qscale = vid_stream->slice.quant_scale;

    DecodeDCTCoeffFirst(i, coeff, diff)

    reconptr[zigzag_direct[i]] = (coeff * qscale *
      (int)vid_stream->non_intra_quant_matrix[i] + 4) >> 3;

    if (vid_stream->picture.code_type != 4) {

      for (;;) {

	i++;

	DecodeDCTCoeffNext(run, coeff, diff, i)

	reconptr[zigzag_direct[i]] = (coeff * qscale *
	  (int)vid_stream->non_intra_quant_matrix[i] + 4) >> 3;
      }

      i -= run; i--;
    }
  }

  if (i == 0) {

    coeff = (*reconptr + 4) >> 3;
    /* Compute 32 bit coeffue to assign. This speeds things up a bit */
    (short)diff = coeff; diff <<= 16; (short)diff = coeff;
    *((long *)reconptr)++ = diff; *((long *)reconptr)++ = diff;
    *((long *)reconptr)++ = diff; *((long *)reconptr)++ = diff;
    *((long *)reconptr)++ = diff; *((long *)reconptr)++ = diff;
    *((long *)reconptr)++ = diff; *((long *)reconptr)++ = diff;
    *((long *)reconptr)++ = diff; *((long *)reconptr)++ = diff;
    *((long *)reconptr)++ = diff; *((long *)reconptr)++ = diff;
    *((long *)reconptr)++ = diff; *((long *)reconptr)++ = diff;
    *((long *)reconptr)++ = diff; *((long *)reconptr)++ = diff;
    *((long *)reconptr)++ = diff; *((long *)reconptr)++ = diff;
    *((long *)reconptr)++ = diff; *((long *)reconptr)++ = diff;
    *((long *)reconptr)++ = diff; *((long *)reconptr)++ = diff;
    *((long *)reconptr)++ = diff; *((long *)reconptr)++ = diff;
    *((long *)reconptr)++ = diff; *((long *)reconptr)++ = diff;
    *((long *)reconptr)++ = diff; *((long *)reconptr)++ = diff;
    *((long *)reconptr)++ = diff; *((long *)reconptr)++ = diff;
    *((long *)reconptr)++ = diff; *((long *)reconptr)++ = diff;
  }
  else j_rev_dct(reconptr, reconptr + 64);
}
	
#undef DCT_recon
#undef DCT_dc_y_past
#undef DCT_dc_cr_past
#undef DCT_dc_cb_past


/*
 *--------------------------------------------------------------
 *
 * ParseAwayBlock --
 *
 *	Parses off block values, throwing them away.
 *      Used with grayscale dithering.
 *
 * Results:
 *	None.
 *
 * Side effects:
 *      None.
 *
 *--------------------------------------------------------------
 */

void ParseAwayBlock( VidStream *vid_stream, int n )
{
  unsigned long diff;
  short coeff, i, run;

  if (vid_stream->mblock.mb_intra) {

    /* If the block is a luminance block... */
    /* Parse and decode size of first coefficient. */

    if (n < 4) DecodeDCTDCSizeLum(coeff, diff)

    /* Otherwise, block is chrominance block... */
    /* Parse and decode size of first coefficient. */

    else DecodeDCTDCSizeChrom(coeff, diff)

    /* Parse off first coefficient. */

    if (coeff >>= 4) flush_bits(coeff)

    i = 0;
  }
  /* Otherwise, block is not intracoded... */
  /* Decode and set first coefficient. */

  else DecodeDCTCoeffFirst(i, coeff, diff)

  /* If picture is not D type (i.e. I, P, or B)... */

  if (vid_stream->picture.code_type != 4)

    /* While end of macroblock has not been reached... */
    /* Get the dct_coeff_next */

    for (;;) {

      i++;

      DecodeDCTCoeffNext(run, coeff, diff, i)
    }
}
